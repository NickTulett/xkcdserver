// Generated by CoffeeScript 2.5.1
(function() {
  define(['cmx/XKCD'], function(XKCD) {
    var Renderer, render, ξ;
    // magic evaluator
    ξ = function(thing, fn) {
      var lastVal;
      lastVal = void 0;
      return function() {
        var val;
        val = thing;
        while (_.isFunction(val)) {
          val = val();
        }
        if (_.isEqual(val, lastVal)) {
          return val;
        }
        if (typeof fn === "function") {
          fn(val);
        }
        return lastVal = val;
      };
    };
    // execute a render call (call properties are bound to this)
    render = function(Δroot, back = false, Δbefore) {
      var backInterpolator, bbox, dynamic, ex, ey, line, magnitude, polyline, textUpdater, xkcd, xkcdInterpolator, xl, yl, Δel, Δpath, Δtext;
      this.updaters || (this.updaters = []);
      // dynamic props can be updated later via update() call
      dynamic = (prop, updater) => {
        var evaluator;
        if (prop === void 0) {
          return;
        }
        evaluator = ξ(prop, updater);
        this.updaters.push(evaluator);
        return evaluator;
      };
      if (this.type === "close group") {
        return d3.select(Δroot.node().parentNode);
      }
      Δel = Δroot;
      if (Δbefore) {
        Δel = Δel.insert("g", Δbefore);
      }
      Δel = Δel.append("g");
      if (this["class"]) {
        Δel.attr("class", this["class"]);
      }
      if (this["data"]) {
        Δel.property("cmx", this["data"]);
      }
      dynamic(this["t"], function(val) {
        if (val) {
          return Δel.attr("transform", val);
        }
      });
      // grouping
      if (this.type === "open group") {
        return Δel;
      }
      // render text
      if (this.type === "text") {
        Δel = Δel.append("g").attr("transform", "scale(1, -1)"); // flip y
        if (back) {
          Δtext = Δel.append("text").attr("class", "cmx-text");
          textUpdater = dynamic(this["text"], function(val) {
            return Δtext.html(val);
          });
          dynamic(this["stroke-width"], function(val) {
            if (val) {
              return Δtext.style("stroke-width", val);
            }
          });
          dynamic(this["bgcolor"], function(val) {
            if (val) {
              return Δtext.style("stroke", val);
            }
          });
          if (this["border"]) {
            textUpdater(); // this is needed for getBBox call
            bbox = Δtext.node().getBBox();
            ex = this["border-extrude-x"] || 8;
            ey = this["border-extrude-y"] || 3;
            polyline = {
              type: "polyline",
              points: [[bbox.x - ex, bbox.y - ey], [bbox.x + bbox.width + ex, bbox.y - ey], [bbox.x + bbox.width + ex, bbox.y + bbox.height + ey], [bbox.x - ex, bbox.y + bbox.height + ey]],
              "class": "cmx-text-border",
              "fill": this["border-fill"],
              "stroke-width": this["border-stroke-width"],
              "stroke": this["border-stroke"],
              "bgcolor": this["border-bgcolor"],
              closed: true
            };
            render.call(polyline, Δel);
            this.updaters.push(function() {
              var j, len1, ref, results, updater;
              ref = polyline.updaters;
              results = [];
              for (j = 0, len1 = ref.length; j < len1; j++) {
                updater = ref[j];
                results.push(updater()); // front
              }
              return results;
            });
          }
        } else {
          Δtext = Δel.append("text").attr("class", "cmx-text");
          dynamic(this["text"], function(val) {
            return Δtext.html(val);
          });
        }
        return Δroot;
      }
      // render polyline
      xl = this['xl'] || [0, 200];
      yl = this['yl'] || [0, 200];
      line = this['line'] || d3.svg.line();
      magnitude = this["magnitude"] || 0.003;
      xkcd = new XKCD();
      xkcdInterpolator = (pts) => {
        var res;
        res = xkcd.render(pts, xl, yl, magnitude);
        if (this["fill"] || this.closed) {
          res += "Z";
        }
        return res;
      };
      backInterpolator = (pts) => {
        var r, result;
        // two decimal places "should be enough for everyone"
        r = function(num) {
          return Math.round(num * 100) / 100;
        };
        result = pts.map(function(d) {
          return [r(d[0]), r(d[1])];
        });
        return result.join("L");
      };
      Δpath = Δel.append("path").attr("class", "cmx-path");
      dynamic(this["fill"], function(val) {
        if (val) {
          return Δpath.style("fill", val);
        }
      });
      if (back) {
        dynamic(this["back-stroke-width"], function(val) {
          if (val) {
            return Δpath.style("stroke-width", val);
          }
        });
        dynamic(this["back-stroke"], function(val) {
          if (val) {
            return Δpath.style("stroke", val);
          }
        });
        dynamic(this["points"], function(val) {
          return Δpath.attr("d", line.interpolate(backInterpolator)(val));
        });
      } else {
        dynamic(this["stroke-width"], function(val) {
          if (val) {
            return Δpath.style("stroke-width", val);
          }
        });
        dynamic(this["stroke"], function(val) {
          if (val) {
            return Δpath.style("stroke", val);
          }
        });
        dynamic(this["points"], function(val) {
          return Δpath.attr("d", line.interpolate(xkcdInterpolator)(val));
        });
      }
      return Δroot;
    };
    return Renderer = class Renderer {
      constructor(root, width, height, marginX = 20, marginY = 20) {
        var fullHeight, fullWidth;
        this.width = width;
        this.height = height;
        this.marginX = marginX;
        this.marginY = marginY;
        this.calls = [];
        fullWidth = this.width + 2 * this.marginX;
        fullHeight = this.height + 2 * this.marginY;
        this.Δsvg = d3.select(root).append("svg").attr("class", "cmx-canvas");
        this.Δsvg.attr("width", fullWidth).attr("height", fullHeight); // svg canvas
        this.Δel = this.Δsvg.append("g").attr("transform", "translate(" + this.marginX + ", " + this.marginY + ")").append("g").attr("transform", "translate(0, " + this.height + ") scale(1, -1)"); // implement margin // flip y
        this.Δlayers = this.Δel.append("g").attr("class", "cmx-layers");
      }

      draw(Δelement) {
        var item, j, k, len1, len2, len3, len4, n, o, ref, ref1, ref2, ref3, Δ;
        if (!Δelement) {
          Δelement = this.Δlayers.append("g").attr("class", "static");
        }
        // draw background line
        Δ = Δelement.append("g").attr("class", "cmx-back");
        ref = this.calls;
        for (j = 0, len1 = ref.length; j < len1; j++) {
          item = ref[j];
          Δ = render.call(item, Δ, true);
        }
        // draw foreground line
        Δ = Δelement.append("g").attr("class", "cmx-front");
        ref1 = this.calls;
        for (k = 0, len2 = ref1.length; k < len2; k++) {
          item = ref1[k];
          Δ = render.call(item, Δ, false);
        }
        ref2 = this.calls;
        // collect all updaters and wrap them into one updater() function
        for (n = 0, len3 = ref2.length; n < len3; n++) {
          item = ref2[n];
          item.update = function() {
            var len4, o, ref3, results, update;
            if (!this.updaters) {
              return;
            }
            ref3 = this.updaters;
            results = [];
            for (o = 0, len4 = ref3.length; o < len4; o++) {
              update = ref3[o];
              results.push(update());
            }
            return results;
          };
        }
        ref3 = this.calls;
        // call initial update on all items
        for (o = 0, len4 = ref3.length; o < len4; o++) {
          item = ref3[o];
          item.update();
        }
        // empty the queue
        this.calls = [];
        return Δelement;
      }

      pushCall(type, opts = {}) {
        opts["type"] = type;
        this.calls.push(opts);
        return opts;
      }

      openGroup(opts = {}) {
        return this.pushCall("open group", opts);
      }

      closeGroup(opts = {}) {
        return this.pushCall("close group", opts);
      }

      text(text, opts = {}) {
        opts["text"] = text;
        return this.pushCall("text", opts);
      }

      line(points, opts = {}) {
        opts["points"] = points;
        return this.pushCall("polyline", opts);
      }

      circle(radius, opts = {}) {
        var N, R, angle, l;
        N = opts["N"] || 20;
        R = opts["radians"] || 2 * Math.PI;
        angle = d3.scale.linear().domain([0, N - 1]).range([0, R]);
        l = d3.svg.line.radial().interpolate("basis").tension(0).radius(radius).angle(function(d, i) {
          return angle(i);
        });
        return this.path(l(d3.range(N)), opts);
      }

      path(spec, opts = {}) {
        var lazyEvaluation;
        lazyEvaluation = () => {
          var delta, flat, i, lastPoints, left, len, mid, minLen, norm, p, p1, path, points, points2, precision, right, t;
          path = document.createElementNS("http://www.w3.org/2000/svg", "path");
          d3.select(path).attr("d", spec);
          // sample the path
          len = path.getTotalLength();
          points = [];
          delta = 1.0;
          t = 0.0;
          while (t < len) {
            p = path.getPointAtLength(t);
            points.push([p.x, p.y]);
            t += delta;
          }
          p1 = path.getPointAtLength(len);
          points.push([p1.x, p1.y]);
          // reduce points
          precision = 10 * (Math.PI / 180); // 10 degrees tollerance
          minLen = 0.1;
          norm = function(v) {
            var l;
            l = Math.sqrt(v[0] * v[0] + v[1] * v[1]);
            if (l < minLen) {
              return;
            }
            return [v[0] / l, v[1] / l];
          };
          flat = function(a, m, b) {
            var angle, dot, va, vb;
            va = norm([m[0] - a[0], m[1] - a[1]]);
            vb = norm([m[0] - b[0], m[1] - b[1]]);
            if (!va || !vb) {
              return true;
            }
            dot = va[0] * vb[0] + va[1] * vb[1];
            if (dot > 1.0) {
              dot = 1.0;
            }
            if (dot < -1.0) {
              dot = -1.0;
            }
            angle = Math.acos(dot);
            return Math.abs(angle - Math.PI) < precision;
          };
          points2 = [points[0]];
          i = 1;
          while (i < points.length - 1) {
            left = points2[points2.length - 1];
            mid = points[i];
            right = points[i + 1];
            if (!flat(left, mid, right)) {
              points2.push(mid);
            }
            i++;
          }
          // add last point
          points2.push(points[points.length - 1]);
          // reduce last 3 points
          if (points2.length >= 3) {
            if (flat(points2[points2.length - 3], points2[points2.length - 2], points2[points2.length - 1])) {
              points2.splice(points2.length - 2, 1);
            }
          }
          return lastPoints = points2;
        };
        return this.line(lazyEvaluation, opts);
      }

    };
  });

}).call(this);
