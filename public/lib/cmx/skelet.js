// Generated by CoffeeScript 2.5.1
(function() {
  define(['cmx/bone'], function(Bone) {
    var Skelet;
    return Skelet = class Skelet {
      constructor(bonedefs = []) {
        this.bones = [];
        this.addBones(bonedefs);
        this.structure = {};
      }

      addBones(bonedefs = []) {
        var args, j, len, list;
        list = [];
        for (j = 0, len = bonedefs.length; j < len; j++) {
          args = bonedefs[j];
          this.bones.push(new Bone(...args));
          list.push(this.bones.length - 1); // push bone index
        }
        return list;
      }

      addStructure(defs = {}) {
        var arg, results, val;
        results = [];
        for (arg in defs) {
          val = defs[arg];
          results.push(this.structure[arg] = val);
        }
        return results;
      }

      boneIndex(name) {
        var bone, i, j, len, ref;
        ref = this.bones;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          bone = ref[i];
          if (name === bone.name) {
            return i;
          }
        }
        return null;
      }

      bone(name) {
        var index;
        index = this.boneIndex(name);
        return this.bones[index];
      }

      bonesWithIndices(boneIndices) {
        return boneIndices.map((index) => {
          return this.bones[index];
        });
      }

      moveBone(boneNames, dx, dy, absolute = false) {
        var affectedBones, bone, boneName, j, len, mx, my, results;
        if (!_.isArray(boneNames)) {
          boneNames = [boneNames];
        }
        results = [];
        for (j = 0, len = boneNames.length; j < len; j++) {
          boneName = boneNames[j];
          bone = this.boneIndex(boneName);
          dx = Math.round(dx);
          dy = Math.round(dy);
          mx = this.bones[bone].x;
          my = this.bones[bone].y;
          if (absolute) {
            this.bones[bone].x = dx;
            this.bones[bone].y = dy;
          } else {
            this.bones[bone].x += dx;
            this.bones[bone].y += dy;
          }
          mx -= this.bones[bone].x;
          my -= this.bones[bone].y;
          affectedBones = this.affectedBones(boneName, false);
          results.push((function() {
            var k, len1, results1;
            results1 = [];
            for (k = 0, len1 = affectedBones.length; k < len1; k++) {
              boneName = affectedBones[k];
              bone = this.boneIndex(boneName);
              this.bones[bone].x -= mx;
              results1.push(this.bones[bone].y -= my);
            }
            return results1;
          }).call(this));
        }
        return results;
      }

      affectedBones(boneNames, addSelf = true) {
        var a, boneName, j, len, res;
        if (!_.isArray(boneNames)) {
          boneNames = [boneNames];
        }
        res = [];
        for (j = 0, len = boneNames.length; j < len; j++) {
          boneName = boneNames[j];
          a = this.structure[boneName];
          if (a) {
            res = res.concat(a);
          }
        }
        if (addSelf) {
          res.concat(boneNames);
        }
        return _.uniq(res);
      }

      getPose(boneIndices) {
        var bone, boneIndex, j, len, pose;
        pose = [];
        for (j = 0, len = boneIndices.length; j < len; j++) {
          boneIndex = boneIndices[j];
          bone = this.bones[boneIndex];
          if (!bone) {
            continue;
          }
          pose.push([bone.x, bone.y]);
        }
        return pose;
      }

      setPose(pose, boneIndices) {
        var i, index, j, len, point, results;
        results = [];
        for (i = j = 0, len = pose.length; j < len; i = ++j) {
          point = pose[i];
          index = boneIndices[i];
          if (index === void 0) {
            continue;
          }
          if (index >= this.bones.length) {
            continue;
          }
          this.bones[index].x = point[0];
          results.push(this.bones[index].y = point[1]);
        }
        return results;
      }

    };
  });

}).call(this);
