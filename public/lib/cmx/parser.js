// Generated by CoffeeScript 2.5.1
(function() {
  define(["cmx/models/scene_model", "cmx/models/actor_model", "cmx/models/bubble_model", "cmx/models/drawing_model", "cmx/models/label_model"], function(...modelClasses) {
    var Parser, defaultModels, i, klass, len;
    // TODO: make public API for adding new models
    defaultModels = {};
    for (i = 0, len = modelClasses.length; i < len; i++) {
      klass = modelClasses[i];
      defaultModels[klass.name] = klass;
    }
    return Parser = class Parser {
      constructor(cmx, models = defaultModels) {
        this.cmx = cmx;
        this.models = models;
      }

      createFrame() {
        this.$frame = $("<iframe>", {
          "class": "cmx-parser",
          frameborder: 0,
          style: "display:none"
        });
        this.$frame.appendTo("body");
        return this.doc = this.$frame.contents().get(0);
      }

      writeContent(markup) {
        this.doc.open();
        this.doc.write(markup);
        return this.doc.close();
      }

      parseMarkup(markup) {
        this.createFrame();
        this.writeContent(markup);
        return this.parseDoc(this.doc);
      }

      lookupModelClass(modelName) {
        return this.models[`${modelName}Model`];
      }

      collectProps($el) {
        var attr, content, e, j, key, len1, params, ref, res, val;
        res = {};
        // special content attribute captures innerHTML
        content = $el.html();
        if (content) {
          res["content"] = content;
        }
        // attributes may be applied via CSS content property
        content = _.str.trim($el.css('content'), " \t\n'");
        if (content && content !== "none") { // Firefox returns "none"
          if (content[0] !== "{") {
            content = `{${content}}`;
          }
          try {
            params = $.parseJSON(content); // TODO: use some non-strict parser for JSON-like data
            $.extend(res, params);
          } catch (error) {
            e = error;
            console.error(e);
          }
        }
        ref = $el.get(0).attributes;
        // collect native attributes
        for (j = 0, len1 = ref.length; j < len1; j++) {
          attr = ref[j];
          key = attr.name.toLowerCase();
          val = attr.value;
          res[key] = val;
        }
        return res;
      }

      parseElement($el) {
        var model, modelClass, props, tag;
        model = $el.data('cmx-model');
        if (!model) {
          tag = _.str.classify($el.prop('tagName').toLowerCase());
          modelClass = this.lookupModelClass(tag);
          if (!modelClass) {
            return;
          }
          // console.error "Unknown cmx tag encountered at ", $el[0]
          model = new modelClass(this.cmx);
          model.source = $el.get(0);
          $el.data('cmx-model', model);
        }
        props = this.collectProps($el);
        model.set(props);
        return model;
      }

      parseDoc(doc) {
        var $doc, $scene, j, len1, ref, res, scene, sceneModel, walk;
        $doc = $(doc);
        walk = ($el) => {
          var $child, child, childModel, j, len1, model, ref;
          model = this.parseElement($el);
          ref = $el.children();
          for (j = 0, len1 = ref.length; j < len1; j++) {
            child = ref[j];
            $child = $(child);
            childModel = walk($child);
            if (!childModel) {
              continue;
            }
            childModel.parent = model;
            model.children.push(childModel);
          }
          return model;
        };
        res = [];
        ref = $doc.find("scene");
        for (j = 0, len1 = ref.length; j < len1; j++) {
          scene = ref[j];
          $scene = $(scene);
          sceneModel = walk($scene);
          sceneModel.source = scene;
          res.push(sceneModel);
        }
        this.cmx.scenes = res;
        return res;
      }

    };
  });

}).call(this);
